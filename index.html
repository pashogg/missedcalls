<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Asterisk Calls Analysis</title>
    <style>
        body {
            font-family: Calibri, Arial, sans-serif;
            margin: 10px;
            background-color: #f0f0f0;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 15px;
            border-radius: 6px;
            box-shadow: 0 1px 5px rgba(0,0,0,0.1);
        }
        
        h1 {
            text-align: center;
            color: #e53935;
            margin-bottom: 20px;
            font-size: 24px;
        }
        
        .buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .btn {
            background-color: #e53935;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 14px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
            font-family: Calibri, Arial, sans-serif;
        }
        
        .btn:hover {
            background-color: #c62828;
        }
        
        .btn:disabled {
            background-color: #9e9e9e;
            cursor: not-allowed;
        }
        
        .btn-toggle {
            background-color: #4caf50;
        }
        
        .btn-toggle:hover {
            background-color: #388e3c;
        }
        
        .btn-delete {
            background-color: #ff9800;
        }
        
        .btn-delete:hover {
            background-color: #f57c00;
        }
        
        .file-input {
            display: none;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            font-family: Calibri, Arial, sans-serif;
            font-size: 14px;
            table-layout: fixed;
        }
        
        th, td {
            border: 1px solid #bdbdbd;
            padding: 8px;
            text-align: left;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        th {
            background-color: #eeeeee;
            font-weight: bold;
        }
        
        tr:nth-child(even) {
            background-color: #fafafa;
        }
        
        .no-data {
            text-align: center;
            padding: 30px;
            color: #757575;
            font-style: italic;
        }
        
        .status-missed {
            background-color: #fff8e1;
            color: #5d4037;
        }
        
        .status-ivr {
            background-color: #ffebee;
            color: #b71c1c;
        }
        
        .status-night {
            background-color: #e3f2fd;
            color: #0d47a1;
        }
        
        .re-called {
            background-color: #e8f5e9;
            color: #1b5e20;
        }
        
        .not-re-called {
            background-color: #ffebee;
            color: #b71c1c;
        }
        
        .section {
            margin-bottom: 25px;
        }
        
        .section-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 12px;
            color: #e53935;
            border-bottom: 2px solid #e53935;
            padding-bottom: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .toggle-btn {
            background: none;
            border: none;
            color: #e53935;
            cursor: pointer;
            font-size: 12px;
            text-decoration: underline;
        }
        
        .delete-btn {
            background: none;
            border: none;
            color: #ff9800;
            cursor: pointer;
            font-size: 12px;
            text-decoration: underline;
            padding: 2px 5px;
        }
        
        .analytics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .analytics-card {
            background: linear-gradient(135deg, #e53935 0%, #c62828 100%);
            color: white;
            padding: 15px;
            border-radius: 6px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .analytics-card h3 {
            margin: 0 0 8px 0;
            font-size: 16px;
        }
        
        .analytics-value {
            font-size: 28px;
            font-weight: bold;
            margin: 8px 0;
        }
        
        .analytics-description {
            font-size: 12px;
            opacity: 0.9;
        }
        
        .hidden {
            display: none;
        }
        
        .chart-container {
            background-color: #fafafa;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
        }
        
        .chart-title {
            text-align: center;
            margin-bottom: 12px;
            color: #e53935;
            font-weight: bold;
            font-size: 16px;
        }
        
        .chart-grid {
            display: grid;
            grid-template-columns: 1fr 3fr;
            gap: 15px;
        }
        
        .date-filter-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .date-filter-label {
            font-weight: bold;
            color: #616161;
            font-size: 14px;
            white-space: nowrap;
        }
        
        .date-filter-select {
            padding: 4px;
            border-radius: 4px;
            border: 1px solid #bdbdbd;
            font-size: 14px;
        }
        
        .chart-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .donut-legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 12px;
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }
        
        @media (max-width: 768px) {
            .chart-grid {
                grid-template-columns: 1fr;
            }
            
            .container {
                padding: 10px;
            }
            
            .buttons {
                gap: 8px;
            }
            
            .btn {
                padding: 8px 16px;
                font-size: 13px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Asterisk Calls Analysis</h1>
        
        <div class="buttons">
            <button id="importBtn" class="btn">Import CSV</button>
            <button id="exportBtn" class="btn" disabled>Export All Data to CSV</button>
            <input type="file" id="fileInput" class="file-input" accept=".csv">
        </div>
        
        <div class="analytics-grid">
            <div class="analytics-card">
                <h3>Total Calls</h3>
                <div class="analytics-value" id="totalCalls">0</div>
                <div class="analytics-description">All processed calls</div>
            </div>
            <div class="analytics-card">
                <h3>Missed Calls</h3>
                <div class="analytics-value" id="missedCallsCount">0</div>
                <div class="analytics-description">Calls not answered</div>
            </div>
            <div class="analytics-card">
                <h3>Night Calls</h3>
                <div class="analytics-value" id="nightCallsCount">0</div>
                <div class="analytics-description">Playback/Hangup calls</div>
            </div>
            <div class="analytics-card">
                <h3>Recall Rate</h3>
                <div class="analytics-value" id="recallRate">0%</div>
                <div class="analytics-description">Calls recalled by customers</div>
            </div>
        </div>
        
        <div class="chart-grid">
            <div class="chart-container">
                <div class="chart-title">Call Status Distribution</div>
                <div class="chart-wrapper">
                    <canvas id="statusChart" width="200" height="200"></canvas>
                    <div class="donut-legend" id="donutLegend"></div>
                </div>
            </div>
            
            <div class="chart-container">
                <div class="chart-title">Call Load by Hour</div>
                <div class="date-filter-container">
                    <span class="date-filter-label">Select Date:</span>
                    <select id="dateFilter" class="date-filter-select">
                        <option value="all">All Dates</option>
                    </select>
                </div>
                <div class="chart-wrapper">
                    <canvas id="hourlyChart" width="540" height="200"></canvas>
                </div>
            </div>
        </div>
        
        <div class="section">
            <div class="section-title">
                <span>Missed Calls</span>
                <button class="toggle-btn" onclick="toggleTable('callsTableSection')">Hide/Show</button>
            </div>
            <div id="callsTableSection">
                <table id="callsTable">
                    <thead>
                        <tr>
                            <th style="width: 10%;">Date</th>
                            <th style="width: 10%;">Time</th>
                            <th style="width: 20%;">Phone Number</th>
                            <th style="width: 20%;">Destination</th>
                            <th style="width: 20%;">Status</th>
                            <th style="width: 15%;">Recalled</th>
                            <th style="width: 5%;">Actions</th>
                        </tr>
                    </thead>
                    <tbody id="tableBody">
                        <tr>
                            <td colspan="7" class="no-data">Upload CSV file to display data</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
        
        <div class="section">
            <div class="section-title">
                <span>Night Calls</span>
                <button class="toggle-btn" onclick="toggleTable('nightTableSection')">Hide/Show</button>
            </div>
            <div id="nightTableSection">
                <table id="nightTable">
                    <thead>
                        <tr>
                            <th style="width: 10%;">Date</th>
                            <th style="width: 10%;">Time</th>
                            <th style="width: 20%;">Phone Number</th>
                            <th style="width: 20%;">Destination</th>
                            <th style="width: 20%;">Status</th>
                            <th style="width: 15%;">Recalled</th>
                            <th style="width: 5%;">Actions</th>
                        </tr>
                    </thead>
                    <tbody id="nightTableBody">
                        <tr>
                            <td colspan="7" class="no-data">Upload CSV file to display data</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
        let allCalls = [];
        let missedCalls = [];
        let nightCalls = [];
        let uniqueDates = [];
        
        // Chart canvas contexts
        const statusCanvas = document.getElementById('statusChart');
        const statusCtx = statusCanvas.getContext('2d');
        
        const hourlyCanvas = document.getElementById('hourlyChart');
        const hourlyCtx = hourlyCanvas.getContext('2d');
        
        const dateFilter = document.getElementById('dateFilter');
        const donutLegend = document.getElementById('donutLegend');
        
        document.getElementById('importBtn').addEventListener('click', () => {
            document.getElementById('fileInput').click();
        });
        
        document.getElementById('fileInput').addEventListener('change', handleFileSelect);
        document.getElementById('exportBtn').addEventListener('click', exportToCSV);
        dateFilter.addEventListener('change', drawHourlyChart);
        
        function toggleTable(sectionId) {
            const section = document.getElementById(sectionId);
            section.classList.toggle('hidden');
        }
        
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const csvData = e.target.result;
                processData(csvData);
            };
            reader.readAsText(file, 'utf-8');
        }
        
        function parseRussianDate(dateStr) {
            // Parse date in format "19.05.2025 19:05"
            const parts = dateStr.split(' ');
            if (parts.length !== 2) return null;
            
            const datePart = parts[0];
            const timePart = parts[1];
            
            const dateParts = datePart.split('.');
            if (dateParts.length !== 3) return null;
            
            const day = parseInt(dateParts[0], 10);
            const month = parseInt(dateParts[1], 10) - 1; // JS months are 0-based
            const year = parseInt(dateParts[2], 10);
            
            const timeParts = timePart.split(':');
            if (timeParts.length !== 2) return null;
            
            const hour = parseInt(timeParts[0], 10);
            const minute = parseInt(timeParts[1], 10);
            
            return new Date(year, month, day, hour, minute);
        }
        
        function formatDateForFilter(date) {
            // Format date as DD.MM.YYYY for filter options
            const day = String(date.getDate()).padStart(2, '0');
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const year = date.getFullYear();
            return `${day}.${month}.${year}`;
        }
        
        function formatDate(dateStr) {
            // Extract date part from "19.05.2025 19:05" -> "19.05.2025"
            const parts = dateStr.split(' ');
            return parts[0];
        }
        
        function formatTime(dateStr) {
            // Extract time part from "19.05.2025 19:05" -> "19:05"
            const parts = dateStr.split(' ');
            return parts[1];
        }
        
        function deleteCall(callId, callType) {
            if (callType === 'missed') {
                missedCalls = missedCalls.filter(call => call.id !== callId);
            } else if (callType === 'night') {
                nightCalls = nightCalls.filter(call => call.id !== callId);
            }
            
            renderTables();
            updateAnalytics();
            drawCharts();
        }
        
        function processData(csvData) {
            // Parse CSV
            const lines = csvData.split('\n');
            const headers = lines[0].split(';').map(header => header.trim().replace(/"/g, ''));
            
            allCalls = [];
            
            for (let i = 1; i < lines.length; i++) {
                if (!lines[i].trim()) continue;
                
                const values = lines[i].split(';').map(value => value.trim().replace(/"/g, ''));
                if (values.length !== headers.length) continue;
                
                const call = {};
                headers.forEach((header, index) => {
                    call[header] = values[index];
                });
                
                allCalls.push(call);
            }
            
            // Extract unique dates for filter
            uniqueDates = [];
            const dateSet = new Set();
            
            allCalls.forEach(call => {
                try {
                    const date = parseRussianDate(call.calldate);
                    if (date && !isNaN(date.getTime())) {
                        const dateStr = formatDateForFilter(date);
                        dateSet.add(dateStr);
                    }
                } catch (e) {
                    console.error('Error parsing date:', call.calldate, e);
                }
            });
            
            uniqueDates = Array.from(dateSet).sort();
            
            // Populate date filter dropdown
            dateFilter.innerHTML = '<option value="all">All Dates</option>';
            uniqueDates.forEach(date => {
                const option = document.createElement('option');
                option.value = date;
                option.textContent = date;
                dateFilter.appendChild(option);
            });
            
            // Group by uniqueid
            const groupedCalls = {};
            allCalls.forEach(call => {
                if (!groupedCalls[call.uniqueid]) {
                    groupedCalls[call.uniqueid] = [];
                }
                groupedCalls[call.uniqueid].push(call);
            });
            
            // Filter missed calls and night calls
            missedCalls = [];
            nightCalls = [];
            
            Object.values(groupedCalls).forEach((group, groupIndex) => {
                const firstCall = group[0];
                
                // Type 1: Missed in queue
                const hasQueue = group.some(call => call.lastapp === 'Queue');
                const hasAnsweredInQueue = group.some(call => call.lastapp === 'Queue' && call.disposition === 'ANSWERED');
                
                if (hasQueue && !hasAnsweredInQueue) {
                    const clidMatch = firstCall.clid.match(/<(\d+)>/);
                    let phoneNumber = clidMatch ? clidMatch[1] : 'Undefined';
                    
                    // Remove prefix 68 if number starts with it
                    if (phoneNumber.startsWith('68') && phoneNumber.length > 2) {
                        phoneNumber = phoneNumber.substring(2);
                    }
                    
                    missedCalls.push({
                        id: groupIndex,
                        calldate: firstCall.calldate,
                        phoneNumber: phoneNumber,
                        destination: firstCall.dst || 'Undefined',
                        status: 'NO ANSWER',
                        uniqueid: firstCall.uniqueid,
                        clid: firstCall.clid
                    });
                }
                
                // Type 2: Night calls (Playback or Hangup)
                const hasPlayback = group.some(call => call.lastapp === 'Playback');
                const hasHangup = group.some(call => call.lastapp === 'Hangup');
                
                if (hasPlayback || hasHangup) {
                    const clidMatch = firstCall.clid.match(/<(\d+)>/);
                    let phoneNumber = clidMatch ? clidMatch[1] : 'Undefined';
                    
                    // Remove prefix 68 if number starts with it
                    if (phoneNumber.startsWith('68') && phoneNumber.length > 2) {
                        phoneNumber = phoneNumber.substring(2);
                    }
                    
                    nightCalls.push({
                        id: groupIndex,
                        calldate: firstCall.calldate,
                        phoneNumber: phoneNumber,
                        destination: firstCall.dst || 'Undefined',
                        status: hasPlayback ? 'Playback' : 'Hangup',
                        uniqueid: firstCall.uniqueid,
                        clid: firstCall.clid
                    });
                }
            });
            
            // Analyze recalls for ALL calls
            const allCallsToCheck = [...missedCalls, ...nightCalls];
            
            allCallsToCheck.forEach(call => {
                const callTime = parseRussianDate(call.calldate);
                if (!callTime) return;
                
                const phoneNumber = call.phoneNumber;
                
                const hasRecall = allCalls.some(otherCall => {
                    // Skip if it's the same call
                    if (otherCall.uniqueid === call.uniqueid) return false;
                    
                    // Only check answered calls
                    if (otherCall.disposition !== 'ANSWERED') return false;
                    
                    const otherCallTime = parseRussianDate(otherCall.calldate);
                    if (!otherCallTime) return false;
                    
                    // Check if the other call happened after this call
                    if (otherCallTime <= callTime) return false;
                    
                    const clidMatch = otherCall.clid.match(/<(\d+)>/);
                    let otherPhoneNumber = clidMatch ? clidMatch[1] : '';
                    
                    // Remove prefix 68 if number starts with it
                    if (otherPhoneNumber.startsWith('68') && otherPhoneNumber.length > 2) {
                        otherPhoneNumber = otherPhoneNumber.substring(2);
                    }
                    
                    return otherPhoneNumber === phoneNumber;
                });
                
                call.recalled = hasRecall ? 'Yes' : 'No';
            });
            
            renderTables();
            updateAnalytics();
            drawCharts();
            document.getElementById('exportBtn').disabled = (missedCalls.length === 0 && nightCalls.length === 0);
        }
        
        function updateAnalytics() {
            // Calculate total calls - unique calls with Queue, Playback, or Hangup
            const uniqueCallIds = new Set();
            allCalls.forEach(call => {
                if (call.lastapp === 'Queue' || call.lastapp === 'Playback' || call.lastapp === 'Hangup') {
                    uniqueCallIds.add(call.uniqueid);
                }
            });
            
            document.getElementById('totalCalls').textContent = uniqueCallIds.size;
            document.getElementById('missedCallsCount').textContent = missedCalls.length;
            document.getElementById('nightCallsCount').textContent = nightCalls.length;
            
            const totalRecalled = missedCalls.filter(call => call.recalled === 'Yes').length + 
                                 nightCalls.filter(call => call.recalled === 'Yes').length;
            const totalWithRecallCheck = missedCalls.length + nightCalls.length;
            
            const recallRate = totalWithRecallCheck > 0 ? 
                Math.round((totalRecalled / totalWithRecallCheck) * 100) : 0;
            document.getElementById('recallRate').textContent = recallRate + '%';
        }
        
        function drawCharts() {
            drawStatusChart();
            drawHourlyChart();
        }
        
        function drawStatusChart() {
            // Clear canvas
            statusCtx.clearRect(0, 0, statusCanvas.width, statusCanvas.height);
            
            // Chart data
            const data = {
                labels: ['Missed Calls', 'Night Calls'],
                values: [
                    missedCalls.length,
                    nightCalls.length
                ],
                colors: ['#e53935', '#2196f3']
            };
            
            // Calculate total for percentages
            const total = data.values.reduce((sum, value) => sum + value, 0);
            if (total === 0) return;
            
            // Draw donut chart
            const centerX = statusCanvas.width / 2;
            const centerY = statusCanvas.height / 2;
            const outerRadius = Math.min(centerX, centerY) - 20;
            const innerRadius = outerRadius * 0.6;
            
            let startAngle = 0;
            
            // Draw donut slices
            data.values.forEach((value, index) => {
                const sliceAngle = (value / total) * 2 * Math.PI;
                const endAngle = startAngle + sliceAngle;
                
                // Draw slice
                statusCtx.beginPath();
                statusCtx.arc(centerX, centerY, outerRadius, startAngle, endAngle);
                statusCtx.arc(centerX, centerY, innerRadius, endAngle, startAngle, true);
                statusCtx.closePath();
                statusCtx.fillStyle = data.colors[index];
                statusCtx.fill();
                
                // Draw border
                statusCtx.strokeStyle = '#fff';
                statusCtx.lineWidth = 1;
                statusCtx.stroke();
                
                // Draw percentage label in the middle of the slice
                if (value > 0) {
                    const midAngle = startAngle + sliceAngle / 2;
                    const labelRadius = (outerRadius + innerRadius) / 2;
                    const labelX = centerX + labelRadius * Math.cos(midAngle);
                    const labelY = centerY + labelRadius * Math.sin(midAngle);
                    
                    statusCtx.fillStyle = '#fff';
                    statusCtx.font = 'bold 12px Calibri';
                    statusCtx.textAlign = 'center';
                    statusCtx.textBaseline = 'middle';
                    const percentage = Math.round((value / total) * 100);
                    statusCtx.fillText(percentage + '%', labelX, labelY);
                }
                
                startAngle = endAngle;
            });
            
            // Draw center circle
            statusCtx.beginPath();
            statusCtx.arc(centerX, centerY, innerRadius, 0, 2 * Math.PI);
            statusCtx.fillStyle = '#fff';
            statusCtx.fill();
            statusCtx.strokeStyle = '#e0e0e0';
            statusCtx.lineWidth = 1;
            statusCtx.stroke();
            
            // Create legend
            donutLegend.innerHTML = '';
            data.labels.forEach((label, index) => {
                const legendItem = document.createElement('div');
                legendItem.className = 'legend-item';
                
                const colorBox = document.createElement('div');
                colorBox.className = 'legend-color';
                colorBox.style.backgroundColor = data.colors[index];
                
                const labelSpan = document.createElement('span');
                labelSpan.textContent = label;
                
                legendItem.appendChild(colorBox);
                legendItem.appendChild(labelSpan);
                donutLegend.appendChild(legendItem);
            });
        }
        
        function drawHourlyChart() {
            // Clear canvas
            hourlyCtx.clearRect(0, 0, hourlyCanvas.width, hourlyCanvas.height);
            
            // Get selected date
            const selectedDate = dateFilter.value;
            
            // Prepare hourly data
            const hourlyData = new Array(24).fill(0);
            
            // Count calls by hour for all call types
            [...missedCalls, ...nightCalls].forEach(call => {
                try {
                    const date = parseRussianDate(call.calldate);
                    if (date && !isNaN(date.getTime())) {
                        // If a specific date is selected, filter by it
                        if (selectedDate !== 'all') {
                            const callDateStr = formatDateForFilter(date);
                            if (callDateStr !== selectedDate) return;
                        }
                        
                        const hour = date.getHours();
                        if (hour >= 0 && hour < 24) {
                            hourlyData[hour]++;
                        }
                    }
                } catch (e) {
                    console.error('Error parsing date:', call.calldate, e);
                }
            });
            
            // Draw bar chart
            const chartWidth = hourlyCanvas.width * 0.9; // 90% of canvas width
            const chartHeight = hourlyCanvas.height - 50;
            const padding = 30;
            const chartX = (hourlyCanvas.width - chartWidth) / 2; // Center the chart
            
            // Find max value for scaling and add 20% margin
            const maxValue = Math.max(...hourlyData, 1) * 1.2;
            
            // Draw grid lines
            hourlyCtx.strokeStyle = '#e0e0e0';
            hourlyCtx.lineWidth = 1;
            hourlyCtx.font = '10px Calibri';
            hourlyCtx.fillStyle = '#616161';
            hourlyCtx.textAlign = 'center';
            
            // Vertical grid lines and hour labels
            for (let i = 0; i < 24; i++) {
                const x = chartX + (i * chartWidth / 23);
                
                // Grid line
                hourlyCtx.beginPath();
                hourlyCtx.moveTo(x, padding);
                hourlyCtx.lineTo(x, padding + chartHeight);
                hourlyCtx.stroke();
                
                // Hour label
                if (i % 2 === 0) { // Show every 2 hours to avoid clutter
                    hourlyCtx.fillText(i + ':00', x, padding + chartHeight + 15);
                }
            }
            
            // Horizontal grid lines and value labels
            const gridLines = 5;
            for (let i = 0; i <= gridLines; i++) {
                const y = padding + chartHeight - (i * chartHeight / gridLines);
                const value = Math.round((i * maxValue) / gridLines);
                
                // Grid line
                hourlyCtx.beginPath();
                hourlyCtx.moveTo(chartX, y);
                hourlyCtx.lineTo(chartX + chartWidth, y);
                hourlyCtx.stroke();
                
                // Value label
                hourlyCtx.textAlign = 'right';
                hourlyCtx.fillText(value, chartX - 5, y + 4);
            }
            
            // Draw bar chart
            const barWidth = chartWidth / 24 * 0.7;
            
            for (let i = 0; i < 24; i++) {
                const x = chartX + (i * chartWidth / 23) - barWidth / 2;
                const barHeight = (hourlyData[i] / maxValue) * chartHeight;
                const y = padding + chartHeight - barHeight;
                
                // Draw bar
                hourlyCtx.fillStyle = '#e53935';
                hourlyCtx.fillRect(x, y, barWidth, barHeight);
                
                // Draw bar border
                hourlyCtx.strokeStyle = '#c62828';
                hourlyCtx.lineWidth = 1;
                hourlyCtx.strokeRect(x, y, barWidth, barHeight);
                
                // Draw value on top of bar if not zero
                if (hourlyData[i] > 0) {
                    hourlyCtx.fillStyle = '#616161';
                    hourlyCtx.font = '10px Calibri';
                    hourlyCtx.textAlign = 'center';
                    hourlyCtx.fillText(hourlyData[i], x + barWidth / 2, y - 10);
                }
            }
            
            // Draw selected date info
            if (selectedDate !== 'all') {
                hourlyCtx.fillStyle = '#616161';
                hourlyCtx.font = '12px Calibri';
                hourlyCtx.textAlign = 'center';
                hourlyCtx.fillText(`Data for: ${selectedDate}`, hourlyCanvas.width / 2, 20);
            }
        }
        
        function renderTables() {
            renderMissedCallsTable();
            renderNightCallsTable();
        }
        
        function renderMissedCallsTable() {
            const tableBody = document.getElementById('tableBody');
            
            if (missedCalls.length === 0) {
                tableBody.innerHTML = '<tr><td colspan="7" class="no-data">No missed calls found</td></tr>';
                return;
            }
            
            tableBody.innerHTML = '';
            
            missedCalls.forEach(call => {
                const row = document.createElement('tr');
                
                // Define classes for status
                let statusClass = '';
                if (call.status === 'NO ANSWER') {
                    statusClass = 'status-missed';
                }
                
                // Define classes for recall
                let recallClass = '';
                if (call.recalled === 'Yes') {
                    recallClass = 're-called';
                } else if (call.recalled === 'No') {
                    recallClass = 'not-re-called';
                }
                
                row.innerHTML = `
                    <td>${formatDate(call.calldate)}</td>
                    <td>${formatTime(call.calldate)}</td>
                    <td>${call.phoneNumber}</td>
                    <td>${call.destination}</td>
                    <td class="${statusClass}">${call.status}</td>
                    <td class="${recallClass}">${call.recalled}</td>
                    <td><button class="delete-btn" onclick="deleteCall(${call.id}, 'missed')">Delete</button></td>
                `;
                
                tableBody.appendChild(row);
            });
        }
        
        function renderNightCallsTable() {
            const tableBody = document.getElementById('nightTableBody');
            
            if (nightCalls.length === 0) {
                tableBody.innerHTML = '<tr><td colspan="7" class="no-data">No night calls found</td></tr>';
                return;
            }
            
            tableBody.innerHTML = '';
            
            nightCalls.forEach(call => {
                const row = document.createElement('tr');
                
                // Define classes for status
                let statusClass = 'status-night';
                
                // Define classes for recall
                let recallClass = '';
                if (call.recalled === 'Yes') {
                    recallClass = 're-called';
                } else if (call.recalled === 'No') {
                    recallClass = 'not-re-called';
                }
                
                row.innerHTML = `
                    <td>${formatDate(call.calldate)}</td>
                    <td>${formatTime(call.calldate)}</td>
                    <td>${call.phoneNumber}</td>
                    <td>${call.destination}</td>
                    <td class="${statusClass}">${call.status}</td>
                    <td class="${recallClass}">${call.recalled}</td>
                    <td><button class="delete-btn" onclick="deleteCall(${call.id}, 'night')">Delete</button></td>
                `;
                
                tableBody.appendChild(row);
            });
        }
        
        function exportToCSV() {
            if (missedCalls.length === 0 && nightCalls.length === 0) return;
            
            // Create CSV headers
            const headers = ['Date', 'Time', 'Phone Number', 'Destination', 'Status', 'Recalled', 'Table Type'];
            let csvContent = 'sep=;\n' + headers.join(';') + '\n';
            
            // Add missed calls data
            missedCalls.forEach(call => {
                const row = [
                    `"${formatDate(call.calldate)}"`,
                    `"${formatTime(call.calldate)}"`,
                    `"${call.phoneNumber}"`,
                    `"${call.destination}"`,
                    `"${call.status}"`,
                    `"${call.recalled}"`,
                    `"Missed Calls"`
                ];
                csvContent += row.join(';') + '\n';
            });
            
            // Add night calls data
            nightCalls.forEach(call => {
                const row = [
                    `"${formatDate(call.calldate)}"`,
                    `"${formatTime(call.calldate)}"`,
                    `"${call.phoneNumber}"`,
                    `"${call.destination}"`,
                    `"${call.status}"`,
                    `"${call.recalled}"`,
                    `"Night Calls"`
                ];
                csvContent += row.join(';') + '\n';
            });
            
            // Create and download file with proper encoding
            const BOM = '\uFEFF';
            const blob = new Blob([BOM, csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            
            const today = new Date();
            const dateString = today.toISOString().split('T')[0];
            link.setAttribute('href', url);
            link.setAttribute('download', `Asterisk_Calls_Analysis_${dateString}.csv`);
            link.style.visibility = 'hidden';
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
    </script>
</body>
</html>